# Fix `TypeError` in `ToolBox._run_async`

## Problem Analysis
The error `TypeError: An asyncio.Future, a coroutine or an awaitable is required` happens in `_run_async` at `return asyncio.run(coro)`.
This means the `coro` object passed to `_run_async` is **NOT** awaitable (e.g., it's `None`, a dict, or a synchronous return value), even though `mcp_registry.call` is expected to be async.

This usually happens if `mcp_registry.call` is synchronous or returns a non-awaitable value, OR if we are incorrectly assuming it needs `asyncio.run`.

## Investigation Steps
1.  **Check `MCPRegistry.call`**: Verify if it is `async def` or returns an awaitable.
2.  **Check `_run_async` Logic**: The logic for "if loop is running" vs "else" seems sound, but the *input* (`coro`) is the suspect.

## Proposed Solution
1.  **Inspect `mcp_client.py`**: We need to see `MCPRegistry.call`.
2.  **Defensive `_run_async`**: Check if `coro` is actually awaitable. If not, just return it directly (it might have executed synchronously).
3.  **Fix `MCPRegistry` if needed**: If it's supposed to be async but isn't, or vice-versa.

## Execution Plan
1.  **Read `deepagent/integrations/mcp_client.py`** to confirm `call` signature.
2.  **Modify `deepagent/core/toolbox.py`**:
    -   Add a check: `if not inspect.isawaitable(coro): return coro`.
    -   This handles cases where the registry might return a cached result or run synchronously.
3.  **Verify**: Run the tool call again.
